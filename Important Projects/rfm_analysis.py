# -*- coding: utf-8 -*-
"""RFM Analysis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wG5gWZ02GikdORK_1rAtRyMWZAL6tD_S

## **CUSTOMER SEGMENTATION**
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import pandas_profiling
from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score
import matplotlib.pyplot as plt
from sklearn.preprocessing import StandardScaler
# %matplotlib inline
import seaborn as sns

from google.colab import files
files.upload()

"""##**DATA WRANGLING**"""

rfm=pd.read_csv('Purchases.csv')

rfm.head()

rfm.shape

rfm.info()

rfm.isna().sum()

rfm['date of purchase']=pd.to_datetime(rfm['date of purchase'])

rfm.info()

rfm['year of purchase']=rfm['date of purchase'].dt.year
rfm['day of purchase']=rfm['date of purchase'].dt.weekday
rfm['month of purchase']=rfm['date of purchase'].dt.month


print(rfm)

rfm['Customer id'].nunique() #No of unique customer ids

rfm.groupby('Customer id',as_index=True).agg({'purchase amount':np.mean}).sort_values('purchase amount',ascending=False).head(5)
#Customer id 222740 and 246480 have the highest average purchase aamount

df=rfm.groupby('year of purchase',as_index=True).agg({'purchase amount':[np.mean,np.sum]})
df=pd.DataFrame(df)
#Purchase amount is increasing year on year
print(df)

type(df)

rfm.groupby('day of purchase',as_index=True).agg({'purchase amount':[np.mean,np.sum]})
#We see average purchase amount is highest on wednesday eventhough it is similar on each day

rfm_month=rfm.groupby('month of purchase',as_index=True).agg({'purchase amount':[np.mean,np.sum]})
rfm_month.reset_index()

rfm_month.columns

plt.figure(figsize=(12,5))
plt.plot(rfm_month[('purchase amount',  'sum')],color='orange')
plt.xlabel('Month')
plt.ylabel('Amount of Sales')
plt.title('Sum of Monthly sales over 10 years')

rfm.describe()

rfm.columns

#extracting Monetary Value
monetary = rfm.groupby('Customer id').agg({'purchase amount':np.sum})
monetary = monetary.reset_index()
monetary.head()

#extracting Frequency
frequency=rfm['Customer id'].value_counts()
type(frequency)
k=pd.DataFrame(frequency)
k=k.reset_index()
k.columns = ['Customer id', "Frequency"]
k.head()

#creating master dataset
master = monetary.merge(k, on = 'Customer id', how = "inner")
master.head()

recency  = rfm[['Customer id','date of purchase']]

max_date=max(recency['date of purchase'])

max_date

#extracting recency
max_date = max_date + pd.DateOffset(days=1)
recency['diff'] = max_date - recency['date of purchase']
recency.head()

recency['date of purchase'].min()

a = recency.groupby('Customer id').agg({'diff':np.min})

a.reset_index(inplace=True)
a

RFM = k.merge(monetary, on = 'Customer id')
RFM = RFM.merge(a, on = 'Customer id')
RFM.head()

RFM

RFM['diff']=RFM['diff'].dt.days

RFM.info()

RFM.describe()

RFM_norm1 = RFM.drop(['Customer id'], axis=1)

"""**KMeans Clustering**"""

sc=StandardScaler()
RFM_norm1 = sc.fit_transform(RFM_norm1)

RFM_norm1 = pd.DataFrame(RFM_norm1)
RFM_norm1.columns = ['Frequency','Amount','Recency']
RFM_norm1.head()

kmeans=KMeans(n_clusters=6,max_iter=500,n_init=50,random_state=123456)
kmeans.fit(RFM_norm1)

kpred=kmeans.predict(RFM_norm1)

RFM_norm1['labels']=kpred

RFM_norm1

RFM_norm1['labels'].value_counts()

silhouette_score(RFM_norm1,RFM_norm1.labels)

kmeans.cluster_centers_

RFM_km = pd.concat([RFM, pd.Series(RFM_norm1['labels'])], axis=1)

RFM_km

df1=RFM_km.groupby('labels').agg({'Frequency':[np.mean],'purchase amount':[np.mean,np.sum],'diff':[np.mean,'count']})

df1.reset_index()

df1.columns

df1['contribution of each segment']=round((df1[('purchase amount',   'sum')]/np.sum(df1[('purchase amount',   'sum')])*100),2)

df1

RFM = RFM.rename(columns={'purchase amount': 'Monetary', 'diff': 'Recency'})

"""Manegarial Segmentation

"""

RFM

# --Calculate R and F groups--
# Create labels for Recency and Frequency
r_labels = range(8, 0, -1); f_labels = range(1,9)
# Assign these labels to 4 equal percentile groups 
r_groups = pd.qcut(RFM['Recency'],q=8, labels=r_labels)
# Assign these labels to 4 equal percentile groups 
f_groups = pd.cut(RFM['Frequency'],bins=8, labels=f_labels)

# Create new columns R and F 
RFM = RFM.assign(R = r_groups.values,F=f_groups.values)

RFM.head()

m_labels = range(1,9)
# Assign these labels to three equal percentile groups 
m_groups = pd.qcut(RFM['Monetary'], q=8, labels=m_labels)
# Create new column M
RFM = RFM.assign(M = m_groups.values)

f_groups.value_counts()

RFM['RFM_Score'] = RFM[['R','F','M']].sum(axis=1)
print(RFM['RFM_Score'].head())

RFM.info()

RFM['RFM_Score'].describe()

# Define rfm_level function
def rfm_level(df):
  if df['RFM_Score'] > 21.375:
    return 'Can\'t Loose Them'
  elif ((df['RFM_Score'] >18.75) and (df['RFM_Score'] <= 21.375)):
    return 'Champions'
  elif ((df['RFM_Score'] >16.125) and (df['RFM_Score'] <=18.75)):
    return 'Loyal'
  elif ((df['RFM_Score'] >13.5) and (df['RFM_Score'] <=16.25)):
    return 'Potential'
  elif ((df['RFM_Score'] > 10.875) and (df['RFM_Score'] <= 13.5)):
    return 'Promising'
  elif ((df['RFM_Score'] > 8.25) and (df['RFM_Score'] <=10.875)):
    return 'Needs Attention'
  elif ((df['RFM_Score'] > 5.625) and (df['RFM_Score'] <=8.25)):
    return 'Require Activation'
  else:
    return 'Lost Customer'
  
# Create a new variable RFM_Level
RFM['RFM_Level'] = RFM.apply(rfm_level, axis=1)
# Print the header with top 5 rows to the console
RFM.head()

rfm_level_agg1 = RFM.groupby('RFM_Level').agg({
    'Recency': 'mean',
    'Frequency': 'mean',
    'Monetary': ['mean', 'count','sum']
}).round(1)
# Print the aggregated dataset
print(rfm_level_agg1)

rfm_level_agg1.columns

# Plot RFM distributions
plt.figure(figsize=(12,10))
# Plot distribution of R
plt.subplot(3, 1, 1); 
sns.distplot(RFM['Recency'],color='r')
# Plot distribution of F
plt.subplot(3, 1, 2); 
sns.distplot(RFM['Frequency'],color='g')
# Plot distribution of M
plt.subplot(3, 1, 3); 
sns.distplot(RFM['Monetary'],color='purple')

RFM.describe()

rfm_level_agg1['percentage contribution']=round((rfm_level_agg1[( 'Monetary',   'sum')]/np.sum(rfm_level_agg1[( 'Monetary',   'sum')])*100),2)

rfm_level_agg1

